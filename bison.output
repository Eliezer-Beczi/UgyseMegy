Terminals unused in grammar

   DOUBLENUMBER
   ASSIGNMENT
   L_CURLY
   R_CURLY
   NOT
   READ
   PRINT
   INTEGER_TYPE
   DOUBLE_TYPE
   VARIABLE_ID
   INT
   FLOAT
   DOUBLE
   STR


Grammar

    0 $accept: START $end

    1 START: PROG
    2      | %empty

    3 PROG: UTASITAS END
    4     | PROG UTASITAS END
    5     | IFBLOCK
    6     | WHILEBLOCK

    7 UTASITAS: KIF

    8 IFBLOCK: IF L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE
    9        | IF L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE ELSE L_ANGLE PROG R_ANGLE

   10 WHILEBLOCK: WHILE L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE

   11 EQUALITY: KIF EQUAL KIF

   12 NOTEQUALITY: KIF NOT_EQUAL KIF

   13 BOOLKIF: EQUALITY
   14        | NOTEQUALITY
   15        | BOOLKIF OR BOOLKIF
   16        | BOOLKIF AND BOOLKIF
   17        | L_ROUND BOOLKIF R_ROUND

   18 KIF: INTNUMBER
   19    | KIF PLUS KIF
   20    | KIF MINUS KIF
   21    | KIF MULTIPLY KIF
   22    | KIF DIVIDE KIF
   23    | L_ROUND KIF R_ROUND


Terminals, with rules where they appear

$end (0) 0
error (256)
INTNUMBER (258) 18
DOUBLENUMBER (259)
PLUS (260) 19
MINUS (261) 20
MULTIPLY (262) 21
DIVIDE (263) 22
ASSIGNMENT (264)
L_BOX (265) 8 9 10
R_BOX (266) 8 9 10
L_ROUND (267) 17 23
R_ROUND (268) 17 23
L_CURLY (269)
R_CURLY (270)
L_ANGLE (271) 8 9 10
R_ANGLE (272) 8 9 10
EQUAL (273) 11
NOT_EQUAL (274) 12
AND (275) 16
OR (276) 15
NOT (277)
END (278) 3 4
READ (279)
PRINT (280)
IF (281) 8 9
ELSE (282) 9
WHILE (283) 10
INTEGER_TYPE (284)
DOUBLE_TYPE (285)
VARIABLE_ID (286)
INT (287)
FLOAT (288)
DOUBLE (289)
STR (290)


Nonterminals, with rules where they appear

$accept (36)
    on left: 0
START (37)
    on left: 1 2, on right: 0
PROG (38)
    on left: 3 4 5 6, on right: 1 4 8 9 10
UTASITAS (39)
    on left: 7, on right: 3 4
IFBLOCK (40)
    on left: 8 9, on right: 5
WHILEBLOCK (41)
    on left: 10, on right: 6
EQUALITY (42)
    on left: 11, on right: 13
NOTEQUALITY (43)
    on left: 12, on right: 14
BOOLKIF (44)
    on left: 13 14 15 16 17, on right: 8 9 10 15 16 17
KIF (45)
    on left: 18 19 20 21 22 23, on right: 7 11 12 19 20 21 22 23


State 0

    0 $accept: . START $end

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2
    IF         shift, and go to state 3
    WHILE      shift, and go to state 4

    $default  reduce using rule 2 (START)

    START       go to state 5
    PROG        go to state 6
    UTASITAS    go to state 7
    IFBLOCK     go to state 8
    WHILEBLOCK  go to state 9
    KIF         go to state 10


State 1

   18 KIF: INTNUMBER .

    $default  reduce using rule 18 (KIF)


State 2

   23 KIF: L_ROUND . KIF R_ROUND

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2

    KIF  go to state 11


State 3

    8 IFBLOCK: IF . L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE
    9        | IF . L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE ELSE L_ANGLE PROG R_ANGLE

    L_BOX  shift, and go to state 12


State 4

   10 WHILEBLOCK: WHILE . L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE

    L_BOX  shift, and go to state 13


State 5

    0 $accept: START . $end

    $end  shift, and go to state 14


State 6

    1 START: PROG .
    4 PROG: PROG . UTASITAS END

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2

    $default  reduce using rule 1 (START)

    UTASITAS  go to state 15
    KIF       go to state 10


State 7

    3 PROG: UTASITAS . END

    END  shift, and go to state 16


State 8

    5 PROG: IFBLOCK .

    $default  reduce using rule 5 (PROG)


State 9

    6 PROG: WHILEBLOCK .

    $default  reduce using rule 6 (PROG)


State 10

    7 UTASITAS: KIF .
   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF

    PLUS      shift, and go to state 17
    MINUS     shift, and go to state 18
    MULTIPLY  shift, and go to state 19
    DIVIDE    shift, and go to state 20

    $default  reduce using rule 7 (UTASITAS)


State 11

   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF
   23    | L_ROUND KIF . R_ROUND

    PLUS      shift, and go to state 17
    MINUS     shift, and go to state 18
    MULTIPLY  shift, and go to state 19
    DIVIDE    shift, and go to state 20
    R_ROUND   shift, and go to state 21


State 12

    8 IFBLOCK: IF L_BOX . BOOLKIF R_BOX L_ANGLE PROG R_ANGLE
    9        | IF L_BOX . BOOLKIF R_BOX L_ANGLE PROG R_ANGLE ELSE L_ANGLE PROG R_ANGLE

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 22

    EQUALITY     go to state 23
    NOTEQUALITY  go to state 24
    BOOLKIF      go to state 25
    KIF          go to state 26


State 13

   10 WHILEBLOCK: WHILE L_BOX . BOOLKIF R_BOX L_ANGLE PROG R_ANGLE

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 22

    EQUALITY     go to state 23
    NOTEQUALITY  go to state 24
    BOOLKIF      go to state 27
    KIF          go to state 26


State 14

    0 $accept: START $end .

    $default  accept


State 15

    4 PROG: PROG UTASITAS . END

    END  shift, and go to state 28


State 16

    3 PROG: UTASITAS END .

    $default  reduce using rule 3 (PROG)


State 17

   19 KIF: KIF PLUS . KIF

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2

    KIF  go to state 29


State 18

   20 KIF: KIF MINUS . KIF

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2

    KIF  go to state 30


State 19

   21 KIF: KIF MULTIPLY . KIF

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2

    KIF  go to state 31


State 20

   22 KIF: KIF DIVIDE . KIF

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2

    KIF  go to state 32


State 21

   23 KIF: L_ROUND KIF R_ROUND .

    $default  reduce using rule 23 (KIF)


State 22

   17 BOOLKIF: L_ROUND . BOOLKIF R_ROUND
   23 KIF: L_ROUND . KIF R_ROUND

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 22

    EQUALITY     go to state 23
    NOTEQUALITY  go to state 24
    BOOLKIF      go to state 33
    KIF          go to state 34


State 23

   13 BOOLKIF: EQUALITY .

    $default  reduce using rule 13 (BOOLKIF)


State 24

   14 BOOLKIF: NOTEQUALITY .

    $default  reduce using rule 14 (BOOLKIF)


State 25

    8 IFBLOCK: IF L_BOX BOOLKIF . R_BOX L_ANGLE PROG R_ANGLE
    9        | IF L_BOX BOOLKIF . R_BOX L_ANGLE PROG R_ANGLE ELSE L_ANGLE PROG R_ANGLE
   15 BOOLKIF: BOOLKIF . OR BOOLKIF
   16        | BOOLKIF . AND BOOLKIF

    R_BOX  shift, and go to state 35
    AND    shift, and go to state 36
    OR     shift, and go to state 37


State 26

   11 EQUALITY: KIF . EQUAL KIF
   12 NOTEQUALITY: KIF . NOT_EQUAL KIF
   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF

    PLUS       shift, and go to state 17
    MINUS      shift, and go to state 18
    MULTIPLY   shift, and go to state 19
    DIVIDE     shift, and go to state 20
    EQUAL      shift, and go to state 38
    NOT_EQUAL  shift, and go to state 39


State 27

   10 WHILEBLOCK: WHILE L_BOX BOOLKIF . R_BOX L_ANGLE PROG R_ANGLE
   15 BOOLKIF: BOOLKIF . OR BOOLKIF
   16        | BOOLKIF . AND BOOLKIF

    R_BOX  shift, and go to state 40
    AND    shift, and go to state 36
    OR     shift, and go to state 37


State 28

    4 PROG: PROG UTASITAS END .

    $default  reduce using rule 4 (PROG)


State 29

   19 KIF: KIF . PLUS KIF
   19    | KIF PLUS KIF .
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF

    MULTIPLY  shift, and go to state 19
    DIVIDE    shift, and go to state 20

    $default  reduce using rule 19 (KIF)


State 30

   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   20    | KIF MINUS KIF .
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF

    MULTIPLY  shift, and go to state 19
    DIVIDE    shift, and go to state 20

    $default  reduce using rule 20 (KIF)


State 31

   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   21    | KIF MULTIPLY KIF .
   22    | KIF . DIVIDE KIF

    $default  reduce using rule 21 (KIF)


State 32

   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF
   22    | KIF DIVIDE KIF .

    $default  reduce using rule 22 (KIF)


State 33

   15 BOOLKIF: BOOLKIF . OR BOOLKIF
   16        | BOOLKIF . AND BOOLKIF
   17        | L_ROUND BOOLKIF . R_ROUND

    R_ROUND  shift, and go to state 41
    AND      shift, and go to state 36
    OR       shift, and go to state 37


State 34

   11 EQUALITY: KIF . EQUAL KIF
   12 NOTEQUALITY: KIF . NOT_EQUAL KIF
   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF
   23    | L_ROUND KIF . R_ROUND

    PLUS       shift, and go to state 17
    MINUS      shift, and go to state 18
    MULTIPLY   shift, and go to state 19
    DIVIDE     shift, and go to state 20
    R_ROUND    shift, and go to state 21
    EQUAL      shift, and go to state 38
    NOT_EQUAL  shift, and go to state 39


State 35

    8 IFBLOCK: IF L_BOX BOOLKIF R_BOX . L_ANGLE PROG R_ANGLE
    9        | IF L_BOX BOOLKIF R_BOX . L_ANGLE PROG R_ANGLE ELSE L_ANGLE PROG R_ANGLE

    L_ANGLE  shift, and go to state 42


State 36

   16 BOOLKIF: BOOLKIF AND . BOOLKIF

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 22

    EQUALITY     go to state 23
    NOTEQUALITY  go to state 24
    BOOLKIF      go to state 43
    KIF          go to state 26


State 37

   15 BOOLKIF: BOOLKIF OR . BOOLKIF

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 22

    EQUALITY     go to state 23
    NOTEQUALITY  go to state 24
    BOOLKIF      go to state 44
    KIF          go to state 26


State 38

   11 EQUALITY: KIF EQUAL . KIF

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2

    KIF  go to state 45


State 39

   12 NOTEQUALITY: KIF NOT_EQUAL . KIF

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2

    KIF  go to state 46


State 40

   10 WHILEBLOCK: WHILE L_BOX BOOLKIF R_BOX . L_ANGLE PROG R_ANGLE

    L_ANGLE  shift, and go to state 47


State 41

   17 BOOLKIF: L_ROUND BOOLKIF R_ROUND .

    $default  reduce using rule 17 (BOOLKIF)


State 42

    8 IFBLOCK: IF L_BOX BOOLKIF R_BOX L_ANGLE . PROG R_ANGLE
    9        | IF L_BOX BOOLKIF R_BOX L_ANGLE . PROG R_ANGLE ELSE L_ANGLE PROG R_ANGLE

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2
    IF         shift, and go to state 3
    WHILE      shift, and go to state 4

    PROG        go to state 48
    UTASITAS    go to state 7
    IFBLOCK     go to state 8
    WHILEBLOCK  go to state 9
    KIF         go to state 10


State 43

   15 BOOLKIF: BOOLKIF . OR BOOLKIF
   16        | BOOLKIF . AND BOOLKIF
   16        | BOOLKIF AND BOOLKIF .

    $default  reduce using rule 16 (BOOLKIF)


State 44

   15 BOOLKIF: BOOLKIF . OR BOOLKIF
   15        | BOOLKIF OR BOOLKIF .
   16        | BOOLKIF . AND BOOLKIF

    $default  reduce using rule 15 (BOOLKIF)


State 45

   11 EQUALITY: KIF EQUAL KIF .
   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF

    PLUS      shift, and go to state 17
    MINUS     shift, and go to state 18
    MULTIPLY  shift, and go to state 19
    DIVIDE    shift, and go to state 20

    $default  reduce using rule 11 (EQUALITY)


State 46

   12 NOTEQUALITY: KIF NOT_EQUAL KIF .
   19 KIF: KIF . PLUS KIF
   20    | KIF . MINUS KIF
   21    | KIF . MULTIPLY KIF
   22    | KIF . DIVIDE KIF

    PLUS      shift, and go to state 17
    MINUS     shift, and go to state 18
    MULTIPLY  shift, and go to state 19
    DIVIDE    shift, and go to state 20

    $default  reduce using rule 12 (NOTEQUALITY)


State 47

   10 WHILEBLOCK: WHILE L_BOX BOOLKIF R_BOX L_ANGLE . PROG R_ANGLE

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2
    IF         shift, and go to state 3
    WHILE      shift, and go to state 4

    PROG        go to state 49
    UTASITAS    go to state 7
    IFBLOCK     go to state 8
    WHILEBLOCK  go to state 9
    KIF         go to state 10


State 48

    4 PROG: PROG . UTASITAS END
    8 IFBLOCK: IF L_BOX BOOLKIF R_BOX L_ANGLE PROG . R_ANGLE
    9        | IF L_BOX BOOLKIF R_BOX L_ANGLE PROG . R_ANGLE ELSE L_ANGLE PROG R_ANGLE

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2
    R_ANGLE    shift, and go to state 50

    UTASITAS  go to state 15
    KIF       go to state 10


State 49

    4 PROG: PROG . UTASITAS END
   10 WHILEBLOCK: WHILE L_BOX BOOLKIF R_BOX L_ANGLE PROG . R_ANGLE

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2
    R_ANGLE    shift, and go to state 51

    UTASITAS  go to state 15
    KIF       go to state 10


State 50

    8 IFBLOCK: IF L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE .
    9        | IF L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE . ELSE L_ANGLE PROG R_ANGLE

    ELSE  shift, and go to state 52

    $default  reduce using rule 8 (IFBLOCK)


State 51

   10 WHILEBLOCK: WHILE L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE .

    $default  reduce using rule 10 (WHILEBLOCK)


State 52

    9 IFBLOCK: IF L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE ELSE . L_ANGLE PROG R_ANGLE

    L_ANGLE  shift, and go to state 53


State 53

    9 IFBLOCK: IF L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE ELSE L_ANGLE . PROG R_ANGLE

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2
    IF         shift, and go to state 3
    WHILE      shift, and go to state 4

    PROG        go to state 54
    UTASITAS    go to state 7
    IFBLOCK     go to state 8
    WHILEBLOCK  go to state 9
    KIF         go to state 10


State 54

    4 PROG: PROG . UTASITAS END
    9 IFBLOCK: IF L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE ELSE L_ANGLE PROG . R_ANGLE

    INTNUMBER  shift, and go to state 1
    L_ROUND    shift, and go to state 2
    R_ANGLE    shift, and go to state 55

    UTASITAS  go to state 15
    KIF       go to state 10


State 55

    9 IFBLOCK: IF L_BOX BOOLKIF R_BOX L_ANGLE PROG R_ANGLE ELSE L_ANGLE PROG R_ANGLE .

    $default  reduce using rule 9 (IFBLOCK)
